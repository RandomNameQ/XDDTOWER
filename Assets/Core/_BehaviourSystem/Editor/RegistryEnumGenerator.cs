using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEngine;

public static class RegistryEnumGenerator
{
    private const string OutputDirAsset = "Assets/Core/CodeGenerated";
    private const string OutputAssetPath = OutputDirAsset + "/RegistryEnums.cs";
    private const string AutoKey = "RegistryEnums_AutoGenerate";
    private static string OutputAbsolutePath => GetAbsolutePath(OutputAssetPath);

    public static bool IsAutoGenerateEnabled()
    {
        return EditorPrefs.GetBool(AutoKey, false);
    }

    private static void SetAutoGenerateEnabled(bool value)
    {
        EditorPrefs.SetBool(AutoKey, value);
    }

    [MenuItem("Tools/Registry/Regenerate Enums")]
    public static void RegenerateMenu()
    {
        GenerateAll();
    }

    [MenuItem("Tools/Registry/Toggle Auto Generate Enums")]
    public static void ToggleAuto()
    {
        var enabled = !IsAutoGenerateEnabled();
        SetAutoGenerateEnabled(enabled);
        Debug.Log($"Registry Enums Auto-Generate: {(enabled ? "ON" : "OFF")}");
    }

    public static void GenerateAll()
    {
        var itemsByType = LoadAllRegistryItemsByType();
        var code = BuildCode(itemsByType);
        WriteIfChanged(OutputAbsolutePath, code, OutputAssetPath);
        RemoveLegacyGeneratedFileIfAny();
    }

    private static Dictionary<Type, List<RegistryItemSO>> LoadAllRegistryItemsByType()
    {
        var result = new Dictionary<Type, List<RegistryItemSO>>();

        // Только те типы, которые используются в GameDatabase.cs
        var allowedTypeNames = new[]
        {
            "TagSO",
            "EffectSO",
            "ActionSO",
            "ModifierSO",
            "AttitudeSO",
            "DirectionSO",
            "StatsSO",
            "OperatinoSO"
        };

        foreach (var typeName in allowedTypeNames)
        {
            var guids = AssetDatabase.FindAssets($"t:{typeName}");
            if (guids.Length == 0) continue;
            
            var list = new List<RegistryItemSO>();
            foreach (var guid in guids)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                var so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);
                if (so == null) continue;
                
                // Проверяем, что это нужный тип
                if (so.GetType().Name != typeName) continue;
                if (!(so is RegistryItemSO registryItem)) continue;
                if (string.IsNullOrEmpty(registryItem.Id)) continue;
                
                list.Add(registryItem);
            }
            if (list.Count > 0)
            {
                // Получаем тип из первого элемента
                var type = list[0].GetType();
                result[type] = list;
            }
        }

        return result;
    }

    private static string BuildCode(Dictionary<Type, List<RegistryItemSO>> itemsByType)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Generated by RegistryEnumGenerator");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("using System;");
        sb.AppendLine();
        sb.AppendLine("namespace GeneratedEnums");
        sb.AppendLine("{");

        foreach (var kv in itemsByType.OrderBy(k => k.Key.Name))
        {
            var type = kv.Key;
            var items = kv.Value;

            var enumName = BuildEnumName(type.Name);
            sb.AppendLine("    [Flags]");
            sb.AppendLine($"    public enum {enumName} : int");
            sb.AppendLine("    {");
            sb.AppendLine("        None = 0,");

            if (items.Count >= 31)
            {
                Debug.LogWarning($"RegistryEnumGenerator: {enumName} has {items.Count} items. [Flags] with int supports up to 31 unique bits (excluding 0). Consider reducing count or switching to long.");
            }

            var usedNames = new HashSet<string>();
            int bitIndex = 0;

            foreach (var item in items.OrderBy(i => i.name, StringComparer.Ordinal))
            {
                var memberName = SanitizeIdentifier(item.name);
                if (string.IsNullOrWhiteSpace(memberName))
                {
                    memberName = "Item";
                }

                if (!usedNames.Add(memberName))
                {
                    var suffix = ShortId(item.Id);
                    memberName = $"{memberName}_{suffix}";
                    usedNames.Add(memberName);
                }

                sb.AppendLine($"        {memberName} = 1 << {bitIndex},");
                bitIndex++;
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string BuildEnumName(string typeName)
    {
        if (typeName.EndsWith("SO", StringComparison.Ordinal))
        {
            typeName = typeName.Substring(0, typeName.Length - 2);
        }
        return typeName + "Id";
    }

    private static string SanitizeIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name)) return "";
        var sb = new StringBuilder(name.Length);
        for (int i = 0; i < name.Length; i++)
        {
            var c = name[i];
            if (i == 0)
            {
                if (char.IsLetter(c) || c == '_' || CharUnicodeInfo.GetUnicodeCategory(c) == System.Globalization.UnicodeCategory.LetterNumber)
                {
                    sb.Append(c);
                }
                else
                {
                    sb.Append('_');
                    if (char.IsDigit(c)) sb.Append(c);
                }
            }
            else
            {
                if (char.IsLetterOrDigit(c) || c == '_') sb.Append(c);
                else sb.Append('_');
            }
        }
        var result = sb.ToString();
        if (string.IsNullOrWhiteSpace(result)) result = "Item";
        return result;
    }

    private static uint First8Hex(string id)
    {
        if (string.IsNullOrEmpty(id)) return 0u;
        var hex = new StringBuilder(8);
        int taken = 0;
        for (int i = 0; i < id.Length && taken < 8; i++)
        {
            char c = id[i];
            bool isHex = (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
            if (isHex)
            {
                hex.Append(c);
                taken++;
            }
        }
        while (hex.Length < 8) hex.Append('0');
        if (uint.TryParse(hex.ToString(), System.Globalization.NumberStyles.HexNumber, null, out var value))
        {
            return value;
        }
        return 0u;
    }

    private static string ShortId(string id)
    {
        if (string.IsNullOrEmpty(id)) return "ID";
        var s = id.Replace("-", "");
        if (s.Length <= 6) return s.ToUpperInvariant();
        return s.Substring(s.Length - 6, 6).ToUpperInvariant();
    }

    private static void WriteIfChanged(string absolutePath, string content, string assetPath)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(absolutePath));
        if (File.Exists(absolutePath))
        {
            var old = File.ReadAllText(absolutePath, Encoding.UTF8);
            if (string.Equals(old, content, StringComparison.Ordinal))
            {
                return;
            }
        }
        File.WriteAllText(absolutePath, content, new UTF8Encoding(false));
        AssetDatabase.ImportAsset(assetPath);
    }

    private static string GetAbsolutePath(string assetPath)
    {
        if (string.IsNullOrEmpty(assetPath)) return string.Empty;
        var assetsRoot = Application.dataPath.Replace("\\", "/");
        var relative = assetPath.StartsWith("Assets/", StringComparison.Ordinal)
            ? assetPath.Substring("Assets/".Length)
            : assetPath;
        var combined = Path.Combine(assetsRoot, relative);
        return combined.Replace("\\", "/");
    }

    private static void RemoveLegacyGeneratedFileIfAny()
    {
        const string legacyAssetPath = "Assets/Core/0_Systemm/CodeGenerated/RegistryEnums.cs";
        var legacyAbsolute = GetAbsolutePath(legacyAssetPath);
        if (File.Exists(legacyAbsolute))
        {
            AssetDatabase.DeleteAsset(legacyAssetPath);
        }
    }

    private static Type[] SafeGetTypes(Assembly assembly)
    {
        try { return assembly.GetTypes(); }
        catch (ReflectionTypeLoadException e) { return e.Types.Where(t => t != null).ToArray(); }
        catch { return Array.Empty<Type>(); }
    }
}

public class RegistryEnumPostprocessor : AssetPostprocessor
{
    private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
    {
        if (!RegistryEnumGenerator.IsAutoGenerateEnabled()) return;
        bool should = false;

        foreach (var p in importedAssets)
        {
            if (IsRelevant(p)) { should = true; break; }
        }
        if (!should)
        {
            foreach (var p in deletedAssets)
            {
                if (IsRelevant(p)) { should = true; break; }
            }
        }
        if (!should)
        {
            foreach (var p in movedAssets)
            {
                if (IsRelevant(p)) { should = true; break; }
            }
        }
        if (!should)
        {
            foreach (var p in movedFromAssetPaths)
            {
                if (IsRelevant(p)) { should = true; break; }
            }
        }

        if (!should) return;

        // Чтобы не триггерить компиляцию на каждом дублировании, откладываем генерацию до окончания batch-импорта
        // В EditorApplication.delayCall мы гарантированно остаёмся в MainThread, но после текущего цикла импорта
        EditorApplication.delayCall += () =>
        {
            if (!RegistryEnumGenerator.IsAutoGenerateEnabled()) return;
            RegistryEnumGenerator.GenerateAll();
        };
    }

    private static bool IsRelevant(string path)
    {
        if (string.IsNullOrEmpty(path)) return false;
        if (!path.EndsWith(".asset", StringComparison.OrdinalIgnoreCase)) return false;
        var obj = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);
        if (obj == null) return false;
        return obj is RegistryItemSO;
    }
}


